Восстановление базы данных - update-database.
Создает 3 поисковика в базе - Yandex, Google и Bing.
Просмотреть их можно на вкладке "Настройки". Там же можно изменить.

При нажатии "Поиск" будут запущены таски для каждой поисковой системы. Таймаут - 3 секунды. Первый резальтат будет выведен на экран. Максимум - 10 записей.

Реализован поиск, как и настройки поисковых систем через парсинг Html Fizzler'ом. Я не использовал api для этих поисковых систем, так как присутствует требование:

"Список поисковиков должен быть легко дополняем"

Поэтому для добавления поисковой системы достаточно зайти в нее, ввести что-нибудь и посмотреть на запрос. Вытащить оттуда шаблон запроса с %query% и css селекторы результатов.

Bing я добавлял вручную, на это ушло 2 минуты и он работает шикарно.

В то же время у google есть подводные камни, он возвращает ссылки в своем формате, который требует обрезания сначала и конца. Можно было бы добавить такой функционал, но получается слишком узкая логика, так как ссылки на обычные сайты, google книги и google картинки различаются шаблонами. Поэтому оставил как есть, но некоторые ссылки вызывают страницу переадресации с google. У Yandex и Bing таких проблем нет.

Yandex поиск плохо настроен, потому что в 95% времени отвергает мои запросы сообщением, что я, скорее всего, робот. Выход только один - использовать api, но они слишком сложны в настройке для добавления обычным пользователем. (хотя тоже можно было сделать что-нибудь, но гораздо дольше)

Поэтому чтобы добиться более-менее нормальной придется шаблоны изменить, но я бы вообще от Yandex'а отказался.

-------------------------------------------------------------------

Теперь немного про код. 
Есть на первый взгял странная цепочка наследования SearchResult от SearchRequest. Она используется для сохранения запроса в результатах поиска.

История поиска удаляется вместе с поисковой системой, так как каскадное удаление в CodeFirst включено по умолчанию.

Поиск по истории идет через совпадение запросов или присутствие запроса в описании результата. Причем в ТЗ было требование

"Ответы от остальных сервисов игнорируются".

Поэтому логика извлечения из кеша аналогична. Тянет только кешированные запросы первой полученной поисковой системы.

В случае если загрузка документа завершается с ошибкой - логирует ошибку. 

Также есть глобальный фильтр для логов, прицепленный к тому же сервису.

Сервис логов закомментирован, на случай, если у вас нет прав на файлы моего пути. Должен выкидываться ексепшен, а мне он для отладки был не нужен.

От ViewModel's в 90% случаев отказался, как и от DTO, так как смысла в общем то и не было. Слишком уж простые процессы и модели. 

В том единственном месте где присутсвует ViewModel, преобразование работает через AutoMapper.

Все репозитории и сервисы встроены через DI контейнер AutoFac для удобства тестрования с помощью NSubstitute.  

В отдельный проект вынес все интерфейсы.

Добавил Generic репозиторий для упрощения себе жизни, от которого наследуются другие репозитории. Все не Generic репозитории удовлетворяют своему уникальному интерфейсу, который в свою очередь наследуюется от Generic интерфейса. Таким образом можно добавлять новые методы в эти интерфейсы и при этом иметь чистый код. К слову, эти другие методы я не добавлял, но возможность есть.
Для того чтобы использовать Generic репозиторий пришлось сделать класс BaseEntity, в котором основной ключ всегда int. Можно было бы использовать другое объявления репозитория, типа GenericRepository<T, TContext, TKey>. Изначально сделаный репозиторий был полностью асинхронным, но потом я понял что это не имеет особого смысла в данно проете, поэтому в SearchConnectorService присутвуют ожидающие .GetAwaiter().GetResult(), чтобы не менять сервис или репозиторий.

--------------------------------------------------------------------

Тестирование

Использовал NUnit.
Тестировал только бизнес-логику, а именно сервисы и один контроллер.
Что касается тестирования контроллеров - я не уверен что это вещь действительно полезная, т.к. совсем понятно что именно в нем тестировать, если в хорошо построенном контроллере нет логики.
Разве что факт верного построения ViewModel'и. Вообще в тестировании контроллеров лучше на QA положиться.
Думаю, актиально только если у вас полный TDD.
Протестировал только HomeController, формально. Использовался TearDown метод для сброса AutoMapper'а.

Чаще всего использовал изолирующий фреймворк NSubstitute, но после понял что метод GetResultPosition содержит логику, которую тоже нужно тестировать, хоть он и является приватным. Поэтому пришлось пометить его virtual и сделать потомка обычной SearchService, чтобы отлавливать факт вызова этого метода и подменять его результат. Службу SearchConnectorService тестировал только на отсутствие id в аргументах и броски exception. Больше там и тестировать то нечего, кроме разве что самого факта вызова функции. Но там даже код не ветвящийся, то есть они 100% будут вызваны. 

Тестировать репозитории тоже не вижу особого смысла. Можно, конечно, но тогда придется подменить контекст. Если использовать изолирующий фреймворк, то придется очень много писать. Если использовать как есть, с реальным подключением к БД, то это уже интеграционное тестирование. И все ради того, чтобы проверить CRUD доступ к БД. В EntityFrameworkCore есть достаточно удобная штука InMemoryDatabase.




